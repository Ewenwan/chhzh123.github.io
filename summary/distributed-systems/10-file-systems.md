---
layout: post
title: 分布式系统（10） - 分布式文件系统
date: 2019-12-16
tag: [summary]
---

<!-- 课本Chap11 -->

## 体系结构
### 客户-服务器体系结构
通常都是client-server的体系结构，典型代表是**NFS(Network File System)**
* 底层模型：**远程文件访问模型**
	- <u>远程访问</u>模型：客户请求访问远程文件，直接在服务器端修改文件
	- <u>上载/下载</u>模型：客户先将文件下载下来，本地修改后再上传
* 特性：网络互连，文件共享，透明，并发，多用户
* 本地UNIX文件系统接口已被虚拟文件系统(VFS)代替，支持硬链接、软链接

{% include image.html fig="DistributedSystems/NFS.png" width="70" %}

### 基于<u>集群</u>的分布式文件系统
当处理非常大的数据集合时，传统client-server架构就不适用了
1. 加速文件访问速度，应用**文件分片划分**技术使文件可以并行访问，类比RAID
	* 将**同一个文件**放在同台服务器上，多台服务器放不同文件
	* 对文件**带区划分并行访问**
2. 将文件划分为较大数据块（如每块64MB），然后将数据块分布、复制到多个物理机器上(Amazon、Google)
	* master在内存中维护了一张(文件名，块服务器)的映射表，以日志形式保存对数据的更新操作，当日志过大时将创建检查点，存储主存数据。实际上是维护了一个名称空间，以及文件名到块的映射。
	* 大量实际工作通过块(chunk)服务器完成，避免master成为瓶颈

### 对称式体系结构
基于P2P技术的完全对称体系结构，其中DHT层采用Chord系统

{% include image.html fig="DistributedSystems/Ivy.png" width="70" %}

## 进程
* 无状态NFS：实现简单，服务器崩溃后不需要恢复；无法访问文件
* 有状态NFS：可以记录各个用户的访问状态（当前目录等等）；需要服务器维护关于客户端的大量信息

## 通信
通常底层都是用RPC实现，传统的每做一次操作都要建一次RPC，后来的则将多次操作合并到一次RPC中，可能会导致很难恢复。
之所以选择RPC是为了使系统独立于底层操作系统、网络和传输协议，但是当需要跨网络访问文件时，就需要另外的方案。

<font size="2" color="blue">注：所以现在才会想用RDMA来做文件系统</font>

## 命名
透明性：和访问本地文件没有差异，通过挂载(mount)实现，但注意不能嵌套挂载

NFS自动挂载是按需挂载，当你要访问某一文件夹时才进行挂载

在文件I/O中，要从一个文件读取数据，应用程序首先要调用操作系统函数并传送文件名，并选一个到该文件的路径来打开文件。该函数取回一个顺序号，即**文件句柄**(file handle)，该文件句柄对于打开的文件是唯一的识别依据。

## 同步
为避免文件共享出现问题，需要精确定义读写操作语义（即时间顺序/并发要求）
* Unix语义：系统对所有操作强加了**绝对时间顺序**，且总返回最新的值
* 会话语义：对**打开**的文件所做的改动只对修改这个文件的进程/机器可见，只有当文件被**关闭**时，这些改动才对其他机器可见
* 只读：只允许read和create
* 事务：所有改动都以原子形式发生

## 一致性和复制
### 客户端缓存
* 当客户打开文件时，将它从服务器获得的数据缓存起来，并将这些数据作为各种读操作的结果；写操作也可在缓存中进行，若文件被修改，客户关闭，则必须送回服务器
* 服务器可将某些权限委托给客户，即开放式委托，将客户请求的文件权限彻底开放给客户

### 复制
主要作用加快搜索和请求速度，平衡结点之间负载。
* 非结构化对等系统：将查找数据归结为搜索网络中的数据
* 结构化对等系统：当从结点P到Q的查询经过R时，R应检查是否将它的任何文件卸载给P，这样可以减轻自己的查询任务

## 容错
### Byzantine容错
* 通过构造有限状态机的集合来部署主动复制，并且这个集合中具有无故障的进程以相同的顺序执行操作
* 服务器组应至少包含3k+1个进程
* 难点在于确保无故障的进程以相同的顺序执行所有操作
* 解决方案：指定一个协调器，通过简单给每个请求附加一个序号来序列化所有操作

{% include image.html fig="DistributedSystems/Byzantine.png" width="70" %}

### P2P系统高度可用性
* 复制
* 擦除编码(erasure coding)：将文件分成 $$ m $$ 块，随后将它们记录到 $$ n>m $$ 块中，核心问题是**任何 $$ m $$ 块编码组合都应该能重构原始文件**