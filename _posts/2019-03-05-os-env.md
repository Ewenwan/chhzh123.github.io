---
layout: post
title: 操作系统环境配置
tag: [tools, os]
---

这学期开设了操作系统课程，需要我们从裸机开始写OS，这篇文章将记录完整的配置过程。

<!--more-->

## 环境说明
* Windows 10 + Ubuntu 18.04 (LTS)
* gcc 7.3.0 + nasm 2.13.02
* Oracle VM VirtualBox 5.2.8

## 创建虚拟软盘
由于大多操作系统实验书籍都采用软盘做引导，但是现在早就没有软盘了，所以只能自己虚拟一个出来。
注意软盘的英文是**floppy** disk！

Linux环境下[创建虚拟软盘](https://untitledfinale.wordpress.com/2007/10/09/create-mount-and-copy-floppy-disks-images-under-linux/)十分简单，用`mkfs`指令即可。
这里我们创建一个1.44M的虚拟软盘。
（古老的算法中将[1MB=1000KB](https://blog.csdn.net/qq_31383385/article/details/79833678)...）
```bash
/sbin/mkfs.msdos -C mydisk.img 1440
```

注意这条指令还将创建的软盘**格式化**了，即可直接作为引导盘使用。
在我的系统上会显示`mkfs.fat 4.1 (2017-01-24)`，意味着已经格式化完毕。

## 编译汇编程序
下面给出一个简单的`Hello world`汇编程序

```assembly
; hello.asm
mov ax, 0xb800
mov ds, ax

mov byte [0x00],'H'
mov byte [0x02],'e'
mov byte [0x04],'l'
mov byte [0x06],'l'
mov byte [0x08],'o'
mov byte [0x10],'W'
mov byte [0x12],'o'
mov byte [0x14],'r'
mov byte [0x16],'l'
mov byte [0x18],'d'

jmp $ ; forever loop

; The last two bytes of the sector should be 0x55aa
times 510-($-$$) db 0
db 0x55,0xaa
```

用`nasm`进行编译
```bash
nasm hello.asm -o hello.bin
```

生成二进制文件流。

## dd指令
用Linux内置的`dd`指令将编译出来的二进制文件复制到虚拟软盘中

```bash
dd if=hello.bin of=myname.img bs=1440k conv=notrunc
```

## 创建虚拟机
1. 打开VirtualBox，点新建，名称XXXPC，类型Other，版本Other/Unknown
2. 内存大小设最小4M即可
3. 不添加虚拟硬盘，然后创建
4. 在创建的XXXPC那里点设置-存储-添加软盘控制器
5. 在“控制器：Floppy后”点添加虚拟软驱
6. 添加刚才构造好的[`img`文件](https://github.com/chhzh123/Assignments/blob/master/OperatingSystems/Lab1/fig/floppy_disk.PNG)

可以见到此时虚拟机的启动顺序为软驱、光驱、硬盘
![virtual machine]({{"/assets/images/OS/virtual_machine_configuration.PNG"|absolute_url}})

## 其他补充
### 软盘
通常一个扇区尺寸是512B，可以看成是一个数据块(block)。
1440KB=1474560B，1B=8b等同于两个hex位。
1.44M的软盘一共包含2880个扇区。

采用磁头、磁道和扇区这种模式来访问硬盘的方法称为CHS模式，但不是很方便。
后来引入了逻辑块地址(Logical Block Address, LBA)的概念。
现在市场上销售的硬盘，无论是哪个厂家生产的，都支持 LBA 模式。

LBA 模式是由硬盘控制器在硬件一级上提供支持，所以效率很高，兼容性很好。
LBA 模式不考虑扇区的物理位置（磁头号、磁道号），而是把它们全部组织起来统一编号。
在这种编址方式下，原先的物理扇区被组织成逻辑扇区，且都有唯一的逻辑扇区号。

比如，某硬盘有6个磁头，每面有1000个磁道，每磁道有17个扇区。那么：
* 逻辑 0 扇区对应着 0 面 0 道 1 扇区
* 逻辑 1 扇区对应着 0 面 0 道 2 扇区
* ……
* 逻辑 16 扇区对应着 0 面 0 道 17 扇区
* 逻辑 17 扇区对应着 1 面 0 道 1 扇区
* 逻辑 18 扇区对应着 1 面 0 道 2 扇区
* ……
* 逻辑 33 扇区对应着 1 面 0 道 17 扇区
* 逻辑 34 扇区对应着 2 面 0 道 1 扇区
* 逻辑 35 扇区对应着 2 面 0 道 2 扇区
* ……
* 逻辑 101999 扇区对应着 5 面 999 道 17 扇区，这也是整个硬盘上最后一个物理扇区

这里面的计算方法是：
LBA=C×磁头总数\*每道扇区数+H\*每道扇区数+(S-1)

查看二进制文件可以用WinHex工具，但不免费...

一般来说，处理器加电或者复位之后，如果硬盘是首选的启动设备，则ROM-BIOS将试图读取硬盘的0面0道1扇区，即主引导扇区 (Main Boot Sector, MBR)。
读取的主引导扇区数据有512字节，ROM-BIOS程序将它加载到逻辑地址`0x0000:0x7c00`处，也就是物理地址`0x07c00`处，然后判断它是否有效。
（注意这里在汇编程序中体现为`org 7c00h`。非常重要！否则无法正确读取代码段/数据段！）

一个**有效的主引导扇区**，其最后两字节应当是`0x55`和`0xAA`（且只能是512B）。ROM-BIOS程序首先检测这两个标志，如果主引导扇区有效，则以一个段间转移指令`jmp 0x0000:0x7c00`跳到那里继续执行。

### x86汇编语言
详情见[x86汇编语言]({% post_url 2019-03-07-x86-asm %})

### 显存
#### 概述
显存，即显示存储器(Video RAM, VRAM)。
要显示的内容都需要先写入显存，显存同样是按字节访问的存储期间。

两种基本工作模式
* 图形模式：每个像素用01控制
* 文本模式：直接用ASCII码控制显示字符的形状

8086可以访问1MB内存，其中0x00000-9FFFF属于常规内存，由内存条提供； 0xF0000-0xFFFFF 由主板上的一个芯片提供，即ROM-BIOS。

这样中间还有一个320KB的空洞，即0xA0000-0xEFFFF。
传统上，这段地址空间由特定的外围设备来提供，其中就包括显卡。
![VRAM]({{"/assets/images/OS/VRAM.PNG"|absolute_url}})

由于历史的原因，所有在个人计算机上使用的显卡，在加电自检之后都会把自己初始化到80\*25 的文本模式。在这种模式下，屏幕上可以显示25行，每行80个字符，每屏总共2000个字符。

所以，0xB8000-0xBFFFF 这段物理地址空间，是留给显卡的，由显卡来提供，用来显示文本。
除非显卡出了毛病，否则这段空间总是可以访问的。
如果显卡出了毛病，计算机一定不会通过加电自检过程，这就是传说中的严重错误，计算机是无法启动的，更不要说加载并执行主引导扇区的内容了。

因此要访问显存，段寄存器要先指向`0xB800`。

#### 80\*25文本模式颜色表
屏幕上的每个字符都对应着显存中连续两个字节，前一字节是字符的ASCII码，后一字节是字符的显示属性。

字符的显示属性分为两部分，低4位定义的是前景色，高4位定义的是背景色。K=0时不闪烁，K=1时闪烁。

| R | G | B | 背景色 | 前景色(I=0) | 前景色(I=1) |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | 黑 | 黑 | 灰 |
| 0 | 0 | 1 | 蓝 | 蓝 | 浅蓝 |
| 0 | 1 | 0 | 绿 | 绿 | 浅绿 |
| 0 | 1 | 1 | 青 | 青 | 浅青 |
| 1 | 0 | 0 | 红 | 红 | 浅红 |
| 1 | 0 | 1 | 品红 | 品红 | 浅品红 |
| 1 | 1 | 0 | 棕 | 棕 | 黄 |
| 1 | 1 | 1 | 白 | 白 | 亮白 |

即连续两个字节为(ASCII)(KRGB)(IRGB)，如`0000 0000 0000 0101`代表黑底（背景）品红字（前景）ASCII码为`0x00`的字符。

### ASCII码表对照
![ascii](https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/060828381f30e924661d9e2c4a086e061d95f776.jpg)

## 参考资料
详细的OS实验请见[Lab1](https://github.com/chhzh123/Assignments/blob/master/OperatingSystems/Lab1)

部分参考资料已在前文以超链接的形式列出
* 李忠，《x86汇编语言-从实模式到保护模式》
* Linux dd指令使用详解，<https://www.cnblogs.com/jikexianfeng/p/6103500.html>