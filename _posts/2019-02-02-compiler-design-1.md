---
layout: post
title: 编译器设计（1）-- 编译概观
tag: compiler
---

本课程采用橡书，Keith D. Cooper和Linda Torczon著，《编译器设计》（第二版）(Engineering a Compiler)。

## 概念
* 编译器：一个大型**软件**系统，用于转换其他计算机程序的计算机**程序**，将一种语言编写的程序转化为另一种语言。通常源语言是高级语言，目标语言是某种处理器的指令集
	> NLP/翻译其实也差不多，只不过对自然语言进行处理难度会更大
* 源到源的转换器：从更高级的语言转化为另一种程序设计语言
* 解释器：源程序输入结果输出
	- 虚拟机：针对某种处理器的模拟器，是针对该机器指令集的解释器

<!--more-->

## 编译器的基本原则
* 正确性：编译器必须保持被编程语言的语义
* 实用性：编译器必须以某种可察觉的方式改进输入程序

## 编译器的结构
三阶段编译器
* 前端：理解源语言程序
* 中间表示(Intermediate Representation, IR)：用某种数据结构表达处理的代码，用于在编译的各个阶段传递信息
	- 引入IR使得可以向编译增加更多阶段，如在前后端中间插入优化器
	- 重定目标：改变编译器使其针对新处理器生成代码的任务
* 后端：将程序映射到目标机
	> 关注点分离

在三阶段中，优化器的描述最为含糊不清，特别是对于*优化*这个术语。
实际上，就算优化过程中某项技术被证明是最优的，与其他技术交互也可能产生次优解。
因此编译器只能改进代码的质量，但通常无法产生最优代码。

### 前端
* 词法分析器(Scanner)：编译器中的一趟(pass)，将字符构成的串转化为单词构成的流
* 语法分析器(Parser)：编译器中的一趟，判断输入流是否为源语言的一个句子
	- 语法：用于定义源语言规则的**有限**集

### 优化器
* 分析：判断编译器可以在何处安全地应用优化技术且有利可图
	- 数据流分析
	- 相关性分析
* 转换：运用分析的结果重写代码

### 后端
* 指令选择：将IR重写为目标机操作
	- 虚拟寄存器：一个符号寄存器名，编译器用其表示某个值可以保存在寄存器中
	- 寄存器分配：将虚拟寄存器映射到实际的目标机寄存器
* 指令调度：重排指令

## 历史
第一个编译器出现在1950s，但已经有一定复杂性了。

而许多有影响力的编译器构建于20世纪六七十年代。

20世纪80年代RISC体系结构的问世导致了另一代编译器的产生，这些编译器专注于强有力的优化和代码生成技术。

而20世纪90年代期间，编译器构造由于对微处理器体系结构中发生的急剧改变作出反映。从Intel i860问世的十年间，编译器编写者面临着种种挑战，如直接管理流水线和内存延迟。

90年代末，编译器面临的诸多挑战包括（处理器）多功能部件、长的内存延迟和并行代码生成。

虽然Java混合使用了编译和解释，但Java并非第一个采用这种混合的语言。
长期以来Lisp早已包含了本机代码编译器和虚拟机实现方案。
Smalltalk-80系统使用了字节码分发和虚拟机，有几个实现了JIT编译器