---
layout: post
title: 编译器设计（2）-- 词法分析器
---

词法分析器/扫描器(scanner)的任务是将**字符流**转化为输入语言的**单词流**，每个单词都必须归类到某个语法范畴(syntactic category)中，也叫词类。

## 概念
* 识别器：可以在字符流中识别特定单词的程序
* 语法范畴/词类：根据单词的语法用途对单词进行的分类
	- 词素：对有限状态机识别的一个单词来说，单词对应的实际文本（即集合下的元素）
* 微语法：语言的词法结构
* 标识符：(类Algol语言C/Java为例)一个字母字符，后接零个或多个字母/数字字符
* 关键字：为特定语法目的而保留的单词，不能作为标识符

<!--more-->

## 有限自动机
有限自动机(Finite Automation/Finite State Machine, FA/FSM)<br/>
$$\mathcal{F}(S,\Sigma,\delta,s_0,S_A)$$
* $$S$$是识别器中的有限状态集，以及一个错误状态$$s_e$$
* $$\Sigma$$是识别器使用的有限字母表，通常是转移图中边的标签的合集
* $$\delta(s,c)$$是识别器的转移函数，将每个状态$$s\in S$$和每个字符$$c\in\Sigma$$的组合$$(s,c)$$映射到下一个状态
* $$s_0\in S$$初始状态
* $$S_A\subset S$$接收/末状态的集合，在状态图中用双层圆圈表示

形式化地讲，若字符串$$x=x_1x_2\cdots x_n$$，则$$\mathcal{F}(S,\Sigma,\delta,s_0,S_A)$$接受(accept)$$x$$的充要条件为

$$\delta(\cdots\delta(s_0,x_1),x_2)\cdots,x_n)\in S_A$$

因每个字符都要进行转移，因此识别器运行时间与输入字符串的长度成正比

如$$S$$为无穷集，如整数集或标识符，则需要有环的状态转移图

## 正则表达式
* 有限状态机$$\mathcal{F}$$所接受的单词的集合，形成一种*语言*$$L(\mathcal{F})$$
* 可用正则表达式(Regular Expression, RE)描述的语言称为*正则语言*

一个RE描述了一个定义在某个字母表$$\Sigma$$上的字符串的集合，外加一个表示空串的字符$$\epsilon$$，将这种集合称为一种语言。
RE有三个基本操作：
* 选择：两个字符串集合的交替或并集，$$S\mid R$$
* 连接：两个字符串的连接，$$RS$$
* 闭包：集合$$R$$的柯林闭包(Kleene closure)$$R^\star=\bigcup_{i=0}^\infty R^i$$，即$$R$$与自身连接零或多次
	- 正闭包：出现次数不为0
	- 有限闭包：$$R^i$$

> Linux的grep(global regular-expression pattern match and print)就是基于正则表达式的模式匹配

优先级：括号>闭包>连接>选择

举例：
* 标识符：`([A..Z]|[a..z])([A..Z]|[a..z]|[0..9])*`
* 无符号整数：`(0|[1..9][0..9]*)(\eps|.[0..9]*)`，注：这里`\eps`代表$$\epsilon$$

正则表达式在基本操作、求补`^`上都是**封闭的**！
同时RE与FA是等价的。

## 非确定性有限状态机(NFA)
由空串输入$$\epsilon$$引起

* 非确定性有限状态机：对单个字符可能有多种可能的转移，如`a*ab`
* 确定性有限状态机(DFA)：每个状态对任一输入字符都有唯一转移

NFA与DFA在表达力上是等价的。任何DFA都是NFA的特例，任何NFA都可以通过DFA模拟
* NFA的配置(configuration)：NFA上并发活动状态的集合

$$NFA(S,\Sigma,\delta,s_0,S_A)$$接受一个输入字符串$$x=x_1x_2\cdots x_n$$的**充要条件**为至少存在一条穿越转移图的路径，起始于状态$$s_0$$，结束于状态$$s_k\in S_A$$，且第$$i$$条边的标签为$$x_i$$（忽略$$\epsilon$$边）

> TODO NFA & DFA